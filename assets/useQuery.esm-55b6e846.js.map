{"version":3,"file":"useQuery.esm-55b6e846.js","sources":["../../src/features/blog/services/devdottoArticle.ts","../../node_modules/.pnpm/@tanstack+query-core@4.22.0/node_modules/@tanstack/query-core/build/lib/subscribable.esm.js","../../node_modules/.pnpm/@tanstack+query-core@4.22.0/node_modules/@tanstack/query-core/build/lib/utils.esm.js","../../node_modules/.pnpm/@tanstack+query-core@4.22.0/node_modules/@tanstack/query-core/build/lib/focusManager.esm.js","../../node_modules/.pnpm/@tanstack+query-core@4.22.0/node_modules/@tanstack/query-core/build/lib/onlineManager.esm.js","../../node_modules/.pnpm/@tanstack+query-core@4.22.0/node_modules/@tanstack/query-core/build/lib/retryer.esm.js","../../node_modules/.pnpm/@tanstack+query-core@4.22.0/node_modules/@tanstack/query-core/build/lib/notifyManager.esm.js","../../node_modules/.pnpm/@tanstack+query-core@4.22.0/node_modules/@tanstack/query-core/build/lib/queryObserver.esm.js","../../node_modules/.pnpm/@tanstack+react-query@4.22.0_biqbaboplfbrettd7655fr4n2y/node_modules/@tanstack/react-query/build/lib/useSyncExternalStore.esm.js","../../node_modules/.pnpm/@tanstack+react-query@4.22.0_biqbaboplfbrettd7655fr4n2y/node_modules/@tanstack/react-query/build/lib/QueryClientProvider.esm.js","../../node_modules/.pnpm/@tanstack+react-query@4.22.0_biqbaboplfbrettd7655fr4n2y/node_modules/@tanstack/react-query/build/lib/isRestoring.esm.js","../../node_modules/.pnpm/@tanstack+react-query@4.22.0_biqbaboplfbrettd7655fr4n2y/node_modules/@tanstack/react-query/build/lib/QueryErrorResetBoundary.esm.js","../../node_modules/.pnpm/@tanstack+react-query@4.22.0_biqbaboplfbrettd7655fr4n2y/node_modules/@tanstack/react-query/build/lib/utils.esm.js","../../node_modules/.pnpm/@tanstack+react-query@4.22.0_biqbaboplfbrettd7655fr4n2y/node_modules/@tanstack/react-query/build/lib/errorBoundaryUtils.esm.js","../../node_modules/.pnpm/@tanstack+react-query@4.22.0_biqbaboplfbrettd7655fr4n2y/node_modules/@tanstack/react-query/build/lib/suspense.esm.js","../../node_modules/.pnpm/@tanstack+react-query@4.22.0_biqbaboplfbrettd7655fr4n2y/node_modules/@tanstack/react-query/build/lib/useBaseQuery.esm.js","../../node_modules/.pnpm/@tanstack+react-query@4.22.0_biqbaboplfbrettd7655fr4n2y/node_modules/@tanstack/react-query/build/lib/useQuery.esm.js"],"sourcesContent":["import DevdottoArticle, { DevdottoArticleMeta } from \"../types/devdottoArticle\";\n\n// Setup API endpoints and queries\nconst DEV_DOT_TO_USERNAME = \"timwjames\";\nconst ARTICLES_API = \"https://dev.to/api/articles\";\n\n// Helper method to type responses\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst parseResponse = <T>(response: any): T =>\n  (typeof response === \"string\" ? JSON.parse(response) : response) as T;\n\n/**\n * Get all articles from dev.to\n *\n */\nexport const devdottoArticlesMeta =\n  (articles: number, page?: number) => async () =>\n    parseResponse<Array<DevdottoArticleMeta>>(\n      (\n        await fetch(\n          ARTICLES_API +\n            \"?\" +\n            new URLSearchParams({\n              username: DEV_DOT_TO_USERNAME,\n              per_page: String(articles),\n              page: String(page || 1),\n            })\n        )\n      ).json()\n    );\n\n/**\n * Get a single dev.to article\n *\n * @param {string} slug - URL slug (title) for the article\n */\nconst devdottoArticle = (slug: string) => async () =>\n  parseResponse<DevdottoArticle>(\n    (await fetch(`${ARTICLES_API}/${DEV_DOT_TO_USERNAME}/${slug}`)).json()\n  );\n\nexport default devdottoArticle;\n","class Subscribable {\n  constructor() {\n    this.listeners = [];\n    this.subscribe = this.subscribe.bind(this);\n  }\n\n  subscribe(listener) {\n    this.listeners.push(listener);\n    this.onSubscribe();\n    return () => {\n      this.listeners = this.listeners.filter(x => x !== listener);\n      this.onUnsubscribe();\n    };\n  }\n\n  hasListeners() {\n    return this.listeners.length > 0;\n  }\n\n  onSubscribe() {// Do nothing\n  }\n\n  onUnsubscribe() {// Do nothing\n  }\n\n}\n\nexport { Subscribable };\n//# sourceMappingURL=subscribable.esm.js.map\n","// TYPES\n// UTILS\nconst isServer = typeof window === 'undefined' || 'Deno' in window;\nfunction noop() {\n  return undefined;\n}\nfunction functionalUpdate(updater, input) {\n  return typeof updater === 'function' ? updater(input) : updater;\n}\nfunction isValidTimeout(value) {\n  return typeof value === 'number' && value >= 0 && value !== Infinity;\n}\nfunction difference(array1, array2) {\n  return array1.filter(x => array2.indexOf(x) === -1);\n}\nfunction replaceAt(array, index, value) {\n  const copy = array.slice(0);\n  copy[index] = value;\n  return copy;\n}\nfunction timeUntilStale(updatedAt, staleTime) {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);\n}\nfunction parseQueryArgs(arg1, arg2, arg3) {\n  if (!isQueryKey(arg1)) {\n    return arg1;\n  }\n\n  if (typeof arg2 === 'function') {\n    return { ...arg3,\n      queryKey: arg1,\n      queryFn: arg2\n    };\n  }\n\n  return { ...arg2,\n    queryKey: arg1\n  };\n}\nfunction parseMutationArgs(arg1, arg2, arg3) {\n  if (isQueryKey(arg1)) {\n    if (typeof arg2 === 'function') {\n      return { ...arg3,\n        mutationKey: arg1,\n        mutationFn: arg2\n      };\n    }\n\n    return { ...arg2,\n      mutationKey: arg1\n    };\n  }\n\n  if (typeof arg1 === 'function') {\n    return { ...arg2,\n      mutationFn: arg1\n    };\n  }\n\n  return { ...arg1\n  };\n}\nfunction parseFilterArgs(arg1, arg2, arg3) {\n  return isQueryKey(arg1) ? [{ ...arg2,\n    queryKey: arg1\n  }, arg3] : [arg1 || {}, arg2];\n}\nfunction parseMutationFilterArgs(arg1, arg2, arg3) {\n  return isQueryKey(arg1) ? [{ ...arg2,\n    mutationKey: arg1\n  }, arg3] : [arg1 || {}, arg2];\n}\nfunction matchQuery(filters, query) {\n  const {\n    type = 'all',\n    exact,\n    fetchStatus,\n    predicate,\n    queryKey,\n    stale\n  } = filters;\n\n  if (isQueryKey(queryKey)) {\n    if (exact) {\n      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {\n        return false;\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false;\n    }\n  }\n\n  if (type !== 'all') {\n    const isActive = query.isActive();\n\n    if (type === 'active' && !isActive) {\n      return false;\n    }\n\n    if (type === 'inactive' && isActive) {\n      return false;\n    }\n  }\n\n  if (typeof stale === 'boolean' && query.isStale() !== stale) {\n    return false;\n  }\n\n  if (typeof fetchStatus !== 'undefined' && fetchStatus !== query.state.fetchStatus) {\n    return false;\n  }\n\n  if (predicate && !predicate(query)) {\n    return false;\n  }\n\n  return true;\n}\nfunction matchMutation(filters, mutation) {\n  const {\n    exact,\n    fetching,\n    predicate,\n    mutationKey\n  } = filters;\n\n  if (isQueryKey(mutationKey)) {\n    if (!mutation.options.mutationKey) {\n      return false;\n    }\n\n    if (exact) {\n      if (hashQueryKey(mutation.options.mutationKey) !== hashQueryKey(mutationKey)) {\n        return false;\n      }\n    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {\n      return false;\n    }\n  }\n\n  if (typeof fetching === 'boolean' && mutation.state.status === 'loading' !== fetching) {\n    return false;\n  }\n\n  if (predicate && !predicate(mutation)) {\n    return false;\n  }\n\n  return true;\n}\nfunction hashQueryKeyByOptions(queryKey, options) {\n  const hashFn = (options == null ? void 0 : options.queryKeyHashFn) || hashQueryKey;\n  return hashFn(queryKey);\n}\n/**\n * Default query keys hash function.\n * Hashes the value into a stable hash.\n */\n\nfunction hashQueryKey(queryKey) {\n  return JSON.stringify(queryKey, (_, val) => isPlainObject(val) ? Object.keys(val).sort().reduce((result, key) => {\n    result[key] = val[key];\n    return result;\n  }, {}) : val);\n}\n/**\n * Checks if key `b` partially matches with key `a`.\n */\n\nfunction partialMatchKey(a, b) {\n  return partialDeepEqual(a, b);\n}\n/**\n * Checks if `b` partially matches with `a`.\n */\n\nfunction partialDeepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (typeof a !== typeof b) {\n    return false;\n  }\n\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    return !Object.keys(b).some(key => !partialDeepEqual(a[key], b[key]));\n  }\n\n  return false;\n}\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\n\nfunction replaceEqualDeep(a, b) {\n  if (a === b) {\n    return a;\n  }\n\n  const array = isPlainArray(a) && isPlainArray(b);\n\n  if (array || isPlainObject(a) && isPlainObject(b)) {\n    const aSize = array ? a.length : Object.keys(a).length;\n    const bItems = array ? b : Object.keys(b);\n    const bSize = bItems.length;\n    const copy = array ? [] : {};\n    let equalItems = 0;\n\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i];\n      copy[key] = replaceEqualDeep(a[key], b[key]);\n\n      if (copy[key] === a[key]) {\n        equalItems++;\n      }\n    }\n\n    return aSize === bSize && equalItems === aSize ? a : copy;\n  }\n\n  return b;\n}\n/**\n * Shallow compare objects. Only works with objects that always have the same properties.\n */\n\nfunction shallowEqualObjects(a, b) {\n  if (a && !b || b && !a) {\n    return false;\n  }\n\n  for (const key in a) {\n    if (a[key] !== b[key]) {\n      return false;\n    }\n  }\n\n  return true;\n}\nfunction isPlainArray(value) {\n  return Array.isArray(value) && value.length === Object.keys(value).length;\n} // Copied from: https://github.com/jonschlinkert/is-plain-object\n\nfunction isPlainObject(o) {\n  if (!hasObjectPrototype(o)) {\n    return false;\n  } // If has modified constructor\n\n\n  const ctor = o.constructor;\n\n  if (typeof ctor === 'undefined') {\n    return true;\n  } // If has modified prototype\n\n\n  const prot = ctor.prototype;\n\n  if (!hasObjectPrototype(prot)) {\n    return false;\n  } // If constructor does not have an Object-specific method\n\n\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false;\n  } // Most likely a plain Object\n\n\n  return true;\n}\n\nfunction hasObjectPrototype(o) {\n  return Object.prototype.toString.call(o) === '[object Object]';\n}\n\nfunction isQueryKey(value) {\n  return Array.isArray(value);\n}\nfunction isError(value) {\n  return value instanceof Error;\n}\nfunction sleep(timeout) {\n  return new Promise(resolve => {\n    setTimeout(resolve, timeout);\n  });\n}\n/**\n * Schedules a microtask.\n * This can be useful to schedule state updates after rendering.\n */\n\nfunction scheduleMicrotask(callback) {\n  sleep(0).then(callback);\n}\nfunction getAbortController() {\n  if (typeof AbortController === 'function') {\n    return new AbortController();\n  }\n\n  return;\n}\nfunction replaceData(prevData, data, options) {\n  // Use prev data if an isDataEqual function is defined and returns `true`\n  if (options.isDataEqual != null && options.isDataEqual(prevData, data)) {\n    return prevData;\n  } else if (typeof options.structuralSharing === 'function') {\n    return options.structuralSharing(prevData, data);\n  } else if (options.structuralSharing !== false) {\n    // Structurally share data between prev and new data if needed\n    return replaceEqualDeep(prevData, data);\n  }\n\n  return data;\n}\n\nexport { difference, functionalUpdate, getAbortController, hashQueryKey, hashQueryKeyByOptions, isError, isPlainArray, isPlainObject, isQueryKey, isServer, isValidTimeout, matchMutation, matchQuery, noop, parseFilterArgs, parseMutationArgs, parseMutationFilterArgs, parseQueryArgs, partialDeepEqual, partialMatchKey, replaceAt, replaceData, replaceEqualDeep, scheduleMicrotask, shallowEqualObjects, sleep, timeUntilStale };\n//# sourceMappingURL=utils.esm.js.map\n","import { Subscribable } from './subscribable.esm.js';\nimport { isServer } from './utils.esm.js';\n\nclass FocusManager extends Subscribable {\n  constructor() {\n    super();\n\n    this.setup = onFocus => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const listener = () => onFocus(); // Listen to visibillitychange and focus\n\n\n        window.addEventListener('visibilitychange', listener, false);\n        window.addEventListener('focus', listener, false);\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('visibilitychange', listener);\n          window.removeEventListener('focus', listener);\n        };\n      }\n\n      return;\n    };\n  }\n\n  onSubscribe() {\n    if (!this.cleanup) {\n      this.setEventListener(this.setup);\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      var _this$cleanup;\n\n      (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);\n      this.cleanup = undefined;\n    }\n  }\n\n  setEventListener(setup) {\n    var _this$cleanup2;\n\n    this.setup = setup;\n    (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);\n    this.cleanup = setup(focused => {\n      if (typeof focused === 'boolean') {\n        this.setFocused(focused);\n      } else {\n        this.onFocus();\n      }\n    });\n  }\n\n  setFocused(focused) {\n    this.focused = focused;\n\n    if (focused) {\n      this.onFocus();\n    }\n  }\n\n  onFocus() {\n    this.listeners.forEach(listener => {\n      listener();\n    });\n  }\n\n  isFocused() {\n    if (typeof this.focused === 'boolean') {\n      return this.focused;\n    } // document global can be unavailable in react native\n\n\n    if (typeof document === 'undefined') {\n      return true;\n    }\n\n    return [undefined, 'visible', 'prerender'].includes(document.visibilityState);\n  }\n\n}\nconst focusManager = new FocusManager();\n\nexport { FocusManager, focusManager };\n//# sourceMappingURL=focusManager.esm.js.map\n","import { Subscribable } from './subscribable.esm.js';\nimport { isServer } from './utils.esm.js';\n\nclass OnlineManager extends Subscribable {\n  constructor() {\n    super();\n\n    this.setup = onOnline => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const listener = () => onOnline(); // Listen to online\n\n\n        window.addEventListener('online', listener, false);\n        window.addEventListener('offline', listener, false);\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('online', listener);\n          window.removeEventListener('offline', listener);\n        };\n      }\n\n      return;\n    };\n  }\n\n  onSubscribe() {\n    if (!this.cleanup) {\n      this.setEventListener(this.setup);\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      var _this$cleanup;\n\n      (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);\n      this.cleanup = undefined;\n    }\n  }\n\n  setEventListener(setup) {\n    var _this$cleanup2;\n\n    this.setup = setup;\n    (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);\n    this.cleanup = setup(online => {\n      if (typeof online === 'boolean') {\n        this.setOnline(online);\n      } else {\n        this.onOnline();\n      }\n    });\n  }\n\n  setOnline(online) {\n    this.online = online;\n\n    if (online) {\n      this.onOnline();\n    }\n  }\n\n  onOnline() {\n    this.listeners.forEach(listener => {\n      listener();\n    });\n  }\n\n  isOnline() {\n    if (typeof this.online === 'boolean') {\n      return this.online;\n    }\n\n    if (typeof navigator === 'undefined' || typeof navigator.onLine === 'undefined') {\n      return true;\n    }\n\n    return navigator.onLine;\n  }\n\n}\nconst onlineManager = new OnlineManager();\n\nexport { OnlineManager, onlineManager };\n//# sourceMappingURL=onlineManager.esm.js.map\n","import { focusManager } from './focusManager.esm.js';\nimport { onlineManager } from './onlineManager.esm.js';\nimport { sleep } from './utils.esm.js';\n\nfunction defaultRetryDelay(failureCount) {\n  return Math.min(1000 * 2 ** failureCount, 30000);\n}\n\nfunction canFetch(networkMode) {\n  return (networkMode != null ? networkMode : 'online') === 'online' ? onlineManager.isOnline() : true;\n}\nclass CancelledError {\n  constructor(options) {\n    this.revert = options == null ? void 0 : options.revert;\n    this.silent = options == null ? void 0 : options.silent;\n  }\n\n}\nfunction isCancelledError(value) {\n  return value instanceof CancelledError;\n}\nfunction createRetryer(config) {\n  let isRetryCancelled = false;\n  let failureCount = 0;\n  let isResolved = false;\n  let continueFn;\n  let promiseResolve;\n  let promiseReject;\n  const promise = new Promise((outerResolve, outerReject) => {\n    promiseResolve = outerResolve;\n    promiseReject = outerReject;\n  });\n\n  const cancel = cancelOptions => {\n    if (!isResolved) {\n      reject(new CancelledError(cancelOptions));\n      config.abort == null ? void 0 : config.abort();\n    }\n  };\n\n  const cancelRetry = () => {\n    isRetryCancelled = true;\n  };\n\n  const continueRetry = () => {\n    isRetryCancelled = false;\n  };\n\n  const shouldPause = () => !focusManager.isFocused() || config.networkMode !== 'always' && !onlineManager.isOnline();\n\n  const resolve = value => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onSuccess == null ? void 0 : config.onSuccess(value);\n      continueFn == null ? void 0 : continueFn();\n      promiseResolve(value);\n    }\n  };\n\n  const reject = value => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onError == null ? void 0 : config.onError(value);\n      continueFn == null ? void 0 : continueFn();\n      promiseReject(value);\n    }\n  };\n\n  const pause = () => {\n    return new Promise(continueResolve => {\n      continueFn = value => {\n        if (isResolved || !shouldPause()) {\n          return continueResolve(value);\n        }\n      };\n\n      config.onPause == null ? void 0 : config.onPause();\n    }).then(() => {\n      continueFn = undefined;\n\n      if (!isResolved) {\n        config.onContinue == null ? void 0 : config.onContinue();\n      }\n    });\n  }; // Create loop function\n\n\n  const run = () => {\n    // Do nothing if already resolved\n    if (isResolved) {\n      return;\n    }\n\n    let promiseOrValue; // Execute query\n\n    try {\n      promiseOrValue = config.fn();\n    } catch (error) {\n      promiseOrValue = Promise.reject(error);\n    }\n\n    Promise.resolve(promiseOrValue).then(resolve).catch(error => {\n      var _config$retry, _config$retryDelay;\n\n      // Stop if the fetch is already resolved\n      if (isResolved) {\n        return;\n      } // Do we need to retry the request?\n\n\n      const retry = (_config$retry = config.retry) != null ? _config$retry : 3;\n      const retryDelay = (_config$retryDelay = config.retryDelay) != null ? _config$retryDelay : defaultRetryDelay;\n      const delay = typeof retryDelay === 'function' ? retryDelay(failureCount, error) : retryDelay;\n      const shouldRetry = retry === true || typeof retry === 'number' && failureCount < retry || typeof retry === 'function' && retry(failureCount, error);\n\n      if (isRetryCancelled || !shouldRetry) {\n        // We are done if the query does not need to be retried\n        reject(error);\n        return;\n      }\n\n      failureCount++; // Notify on fail\n\n      config.onFail == null ? void 0 : config.onFail(failureCount, error); // Delay\n\n      sleep(delay) // Pause if the document is not visible or when the device is offline\n      .then(() => {\n        if (shouldPause()) {\n          return pause();\n        }\n\n        return;\n      }).then(() => {\n        if (isRetryCancelled) {\n          reject(error);\n        } else {\n          run();\n        }\n      });\n    });\n  }; // Start loop\n\n\n  if (canFetch(config.networkMode)) {\n    run();\n  } else {\n    pause().then(run);\n  }\n\n  return {\n    promise,\n    cancel,\n    continue: () => {\n      continueFn == null ? void 0 : continueFn();\n    },\n    cancelRetry,\n    continueRetry\n  };\n}\n\nexport { CancelledError, canFetch, createRetryer, isCancelledError };\n//# sourceMappingURL=retryer.esm.js.map\n","import { scheduleMicrotask } from './utils.esm.js';\n\nfunction createNotifyManager() {\n  let queue = [];\n  let transactions = 0;\n\n  let notifyFn = callback => {\n    callback();\n  };\n\n  let batchNotifyFn = callback => {\n    callback();\n  };\n\n  const batch = callback => {\n    let result;\n    transactions++;\n\n    try {\n      result = callback();\n    } finally {\n      transactions--;\n\n      if (!transactions) {\n        flush();\n      }\n    }\n\n    return result;\n  };\n\n  const schedule = callback => {\n    if (transactions) {\n      queue.push(callback);\n    } else {\n      scheduleMicrotask(() => {\n        notifyFn(callback);\n      });\n    }\n  };\n  /**\n   * All calls to the wrapped function will be batched.\n   */\n\n\n  const batchCalls = callback => {\n    return (...args) => {\n      schedule(() => {\n        callback(...args);\n      });\n    };\n  };\n\n  const flush = () => {\n    const originalQueue = queue;\n    queue = [];\n\n    if (originalQueue.length) {\n      scheduleMicrotask(() => {\n        batchNotifyFn(() => {\n          originalQueue.forEach(callback => {\n            notifyFn(callback);\n          });\n        });\n      });\n    }\n  };\n  /**\n   * Use this method to set a custom notify function.\n   * This can be used to for example wrap notifications with `React.act` while running tests.\n   */\n\n\n  const setNotifyFunction = fn => {\n    notifyFn = fn;\n  };\n  /**\n   * Use this method to set a custom function to batch notifications together into a single tick.\n   * By default React Query will use the batch function provided by ReactDOM or React Native.\n   */\n\n\n  const setBatchNotifyFunction = fn => {\n    batchNotifyFn = fn;\n  };\n\n  return {\n    batch,\n    batchCalls,\n    schedule,\n    setNotifyFunction,\n    setBatchNotifyFunction\n  };\n} // SINGLETON\n\nconst notifyManager = createNotifyManager();\n\nexport { createNotifyManager, notifyManager };\n//# sourceMappingURL=notifyManager.esm.js.map\n","import { shallowEqualObjects, noop, isServer, isValidTimeout, timeUntilStale, replaceData } from './utils.esm.js';\nimport { notifyManager } from './notifyManager.esm.js';\nimport { focusManager } from './focusManager.esm.js';\nimport { Subscribable } from './subscribable.esm.js';\nimport { canFetch, isCancelledError } from './retryer.esm.js';\n\nclass QueryObserver extends Subscribable {\n  constructor(client, options) {\n    super();\n    this.client = client;\n    this.options = options;\n    this.trackedProps = new Set();\n    this.selectError = null;\n    this.bindMethods();\n    this.setOptions(options);\n  }\n\n  bindMethods() {\n    this.remove = this.remove.bind(this);\n    this.refetch = this.refetch.bind(this);\n  }\n\n  onSubscribe() {\n    if (this.listeners.length === 1) {\n      this.currentQuery.addObserver(this);\n\n      if (shouldFetchOnMount(this.currentQuery, this.options)) {\n        this.executeFetch();\n      }\n\n      this.updateTimers();\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.listeners.length) {\n      this.destroy();\n    }\n  }\n\n  shouldFetchOnReconnect() {\n    return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnReconnect);\n  }\n\n  shouldFetchOnWindowFocus() {\n    return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnWindowFocus);\n  }\n\n  destroy() {\n    this.listeners = [];\n    this.clearStaleTimeout();\n    this.clearRefetchInterval();\n    this.currentQuery.removeObserver(this);\n  }\n\n  setOptions(options, notifyOptions) {\n    const prevOptions = this.options;\n    const prevQuery = this.currentQuery;\n    this.options = this.client.defaultQueryOptions(options);\n\n    if (process.env.NODE_ENV !== 'production' && typeof (options == null ? void 0 : options.isDataEqual) !== 'undefined') {\n      this.client.getLogger().error(\"The isDataEqual option has been deprecated and will be removed in the next major version. You can achieve the same functionality by passing a function as the structuralSharing option\");\n    }\n\n    if (!shallowEqualObjects(prevOptions, this.options)) {\n      this.client.getQueryCache().notify({\n        type: 'observerOptionsUpdated',\n        query: this.currentQuery,\n        observer: this\n      });\n    }\n\n    if (typeof this.options.enabled !== 'undefined' && typeof this.options.enabled !== 'boolean') {\n      throw new Error('Expected enabled to be a boolean');\n    } // Keep previous query key if the user does not supply one\n\n\n    if (!this.options.queryKey) {\n      this.options.queryKey = prevOptions.queryKey;\n    }\n\n    this.updateQuery();\n    const mounted = this.hasListeners(); // Fetch if there are subscribers\n\n    if (mounted && shouldFetchOptionally(this.currentQuery, prevQuery, this.options, prevOptions)) {\n      this.executeFetch();\n    } // Update result\n\n\n    this.updateResult(notifyOptions); // Update stale interval if needed\n\n    if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || this.options.staleTime !== prevOptions.staleTime)) {\n      this.updateStaleTimeout();\n    }\n\n    const nextRefetchInterval = this.computeRefetchInterval(); // Update refetch interval if needed\n\n    if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || nextRefetchInterval !== this.currentRefetchInterval)) {\n      this.updateRefetchInterval(nextRefetchInterval);\n    }\n  }\n\n  getOptimisticResult(options) {\n    const query = this.client.getQueryCache().build(this.client, options);\n    return this.createResult(query, options);\n  }\n\n  getCurrentResult() {\n    return this.currentResult;\n  }\n\n  trackResult(result) {\n    const trackedResult = {};\n    Object.keys(result).forEach(key => {\n      Object.defineProperty(trackedResult, key, {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n          this.trackedProps.add(key);\n          return result[key];\n        }\n      });\n    });\n    return trackedResult;\n  }\n\n  getCurrentQuery() {\n    return this.currentQuery;\n  }\n\n  remove() {\n    this.client.getQueryCache().remove(this.currentQuery);\n  }\n\n  refetch({\n    refetchPage,\n    ...options\n  } = {}) {\n    return this.fetch({ ...options,\n      meta: {\n        refetchPage\n      }\n    });\n  }\n\n  fetchOptimistic(options) {\n    const defaultedOptions = this.client.defaultQueryOptions(options);\n    const query = this.client.getQueryCache().build(this.client, defaultedOptions);\n    query.isFetchingOptimistic = true;\n    return query.fetch().then(() => this.createResult(query, defaultedOptions));\n  }\n\n  fetch(fetchOptions) {\n    var _fetchOptions$cancelR;\n\n    return this.executeFetch({ ...fetchOptions,\n      cancelRefetch: (_fetchOptions$cancelR = fetchOptions.cancelRefetch) != null ? _fetchOptions$cancelR : true\n    }).then(() => {\n      this.updateResult();\n      return this.currentResult;\n    });\n  }\n\n  executeFetch(fetchOptions) {\n    // Make sure we reference the latest query as the current one might have been removed\n    this.updateQuery(); // Fetch\n\n    let promise = this.currentQuery.fetch(this.options, fetchOptions);\n\n    if (!(fetchOptions != null && fetchOptions.throwOnError)) {\n      promise = promise.catch(noop);\n    }\n\n    return promise;\n  }\n\n  updateStaleTimeout() {\n    this.clearStaleTimeout();\n\n    if (isServer || this.currentResult.isStale || !isValidTimeout(this.options.staleTime)) {\n      return;\n    }\n\n    const time = timeUntilStale(this.currentResult.dataUpdatedAt, this.options.staleTime); // The timeout is sometimes triggered 1 ms before the stale time expiration.\n    // To mitigate this issue we always add 1 ms to the timeout.\n\n    const timeout = time + 1;\n    this.staleTimeoutId = setTimeout(() => {\n      if (!this.currentResult.isStale) {\n        this.updateResult();\n      }\n    }, timeout);\n  }\n\n  computeRefetchInterval() {\n    var _this$options$refetch;\n\n    return typeof this.options.refetchInterval === 'function' ? this.options.refetchInterval(this.currentResult.data, this.currentQuery) : (_this$options$refetch = this.options.refetchInterval) != null ? _this$options$refetch : false;\n  }\n\n  updateRefetchInterval(nextInterval) {\n    this.clearRefetchInterval();\n    this.currentRefetchInterval = nextInterval;\n\n    if (isServer || this.options.enabled === false || !isValidTimeout(this.currentRefetchInterval) || this.currentRefetchInterval === 0) {\n      return;\n    }\n\n    this.refetchIntervalId = setInterval(() => {\n      if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {\n        this.executeFetch();\n      }\n    }, this.currentRefetchInterval);\n  }\n\n  updateTimers() {\n    this.updateStaleTimeout();\n    this.updateRefetchInterval(this.computeRefetchInterval());\n  }\n\n  clearStaleTimeout() {\n    if (this.staleTimeoutId) {\n      clearTimeout(this.staleTimeoutId);\n      this.staleTimeoutId = undefined;\n    }\n  }\n\n  clearRefetchInterval() {\n    if (this.refetchIntervalId) {\n      clearInterval(this.refetchIntervalId);\n      this.refetchIntervalId = undefined;\n    }\n  }\n\n  createResult(query, options) {\n    const prevQuery = this.currentQuery;\n    const prevOptions = this.options;\n    const prevResult = this.currentResult;\n    const prevResultState = this.currentResultState;\n    const prevResultOptions = this.currentResultOptions;\n    const queryChange = query !== prevQuery;\n    const queryInitialState = queryChange ? query.state : this.currentQueryInitialState;\n    const prevQueryResult = queryChange ? this.currentResult : this.previousQueryResult;\n    const {\n      state\n    } = query;\n    let {\n      dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      fetchStatus,\n      status\n    } = state;\n    let isPreviousData = false;\n    let isPlaceholderData = false;\n    let data; // Optimistically set result in fetching state if needed\n\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners();\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options);\n      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);\n\n      if (fetchOnMount || fetchOptionally) {\n        fetchStatus = canFetch(query.options.networkMode) ? 'fetching' : 'paused';\n\n        if (!dataUpdatedAt) {\n          status = 'loading';\n        }\n      }\n\n      if (options._optimisticResults === 'isRestoring') {\n        fetchStatus = 'idle';\n      }\n    } // Keep previous data if needed\n\n\n    if (options.keepPreviousData && !state.dataUpdatedAt && prevQueryResult != null && prevQueryResult.isSuccess && status !== 'error') {\n      data = prevQueryResult.data;\n      dataUpdatedAt = prevQueryResult.dataUpdatedAt;\n      status = prevQueryResult.status;\n      isPreviousData = true;\n    } // Select data if needed\n    else if (options.select && typeof state.data !== 'undefined') {\n      // Memoize select result\n      if (prevResult && state.data === (prevResultState == null ? void 0 : prevResultState.data) && options.select === this.selectFn) {\n        data = this.selectResult;\n      } else {\n        try {\n          this.selectFn = options.select;\n          data = options.select(state.data);\n          data = replaceData(prevResult == null ? void 0 : prevResult.data, data, options);\n          this.selectResult = data;\n          this.selectError = null;\n        } catch (selectError) {\n          if (process.env.NODE_ENV !== 'production') {\n            this.client.getLogger().error(selectError);\n          }\n\n          this.selectError = selectError;\n        }\n      }\n    } // Use query data\n    else {\n      data = state.data;\n    } // Show placeholder data if needed\n\n\n    if (typeof options.placeholderData !== 'undefined' && typeof data === 'undefined' && status === 'loading') {\n      let placeholderData; // Memoize placeholder data\n\n      if (prevResult != null && prevResult.isPlaceholderData && options.placeholderData === (prevResultOptions == null ? void 0 : prevResultOptions.placeholderData)) {\n        placeholderData = prevResult.data;\n      } else {\n        placeholderData = typeof options.placeholderData === 'function' ? options.placeholderData() : options.placeholderData;\n\n        if (options.select && typeof placeholderData !== 'undefined') {\n          try {\n            placeholderData = options.select(placeholderData);\n            this.selectError = null;\n          } catch (selectError) {\n            if (process.env.NODE_ENV !== 'production') {\n              this.client.getLogger().error(selectError);\n            }\n\n            this.selectError = selectError;\n          }\n        }\n      }\n\n      if (typeof placeholderData !== 'undefined') {\n        status = 'success';\n        data = replaceData(prevResult == null ? void 0 : prevResult.data, placeholderData, options);\n        isPlaceholderData = true;\n      }\n    }\n\n    if (this.selectError) {\n      error = this.selectError;\n      data = this.selectResult;\n      errorUpdatedAt = Date.now();\n      status = 'error';\n    }\n\n    const isFetching = fetchStatus === 'fetching';\n    const isLoading = status === 'loading';\n    const isError = status === 'error';\n    const result = {\n      status,\n      fetchStatus,\n      isLoading,\n      isSuccess: status === 'success',\n      isError,\n      isInitialLoading: isLoading && isFetching,\n      data,\n      dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: state.fetchFailureCount,\n      failureReason: state.fetchFailureReason,\n      errorUpdateCount: state.errorUpdateCount,\n      isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,\n      isFetchedAfterMount: state.dataUpdateCount > queryInitialState.dataUpdateCount || state.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching,\n      isRefetching: isFetching && !isLoading,\n      isLoadingError: isError && state.dataUpdatedAt === 0,\n      isPaused: fetchStatus === 'paused',\n      isPlaceholderData,\n      isPreviousData,\n      isRefetchError: isError && state.dataUpdatedAt !== 0,\n      isStale: isStale(query, options),\n      refetch: this.refetch,\n      remove: this.remove\n    };\n    return result;\n  }\n\n  updateResult(notifyOptions) {\n    const prevResult = this.currentResult;\n    const nextResult = this.createResult(this.currentQuery, this.options);\n    this.currentResultState = this.currentQuery.state;\n    this.currentResultOptions = this.options; // Only notify and update result if something has changed\n\n    if (shallowEqualObjects(nextResult, prevResult)) {\n      return;\n    }\n\n    this.currentResult = nextResult; // Determine which callbacks to trigger\n\n    const defaultNotifyOptions = {\n      cache: true\n    };\n\n    const shouldNotifyListeners = () => {\n      if (!prevResult) {\n        return true;\n      }\n\n      const {\n        notifyOnChangeProps\n      } = this.options;\n\n      if (notifyOnChangeProps === 'all' || !notifyOnChangeProps && !this.trackedProps.size) {\n        return true;\n      }\n\n      const includedProps = new Set(notifyOnChangeProps != null ? notifyOnChangeProps : this.trackedProps);\n\n      if (this.options.useErrorBoundary) {\n        includedProps.add('error');\n      }\n\n      return Object.keys(this.currentResult).some(key => {\n        const typedKey = key;\n        const changed = this.currentResult[typedKey] !== prevResult[typedKey];\n        return changed && includedProps.has(typedKey);\n      });\n    };\n\n    if ((notifyOptions == null ? void 0 : notifyOptions.listeners) !== false && shouldNotifyListeners()) {\n      defaultNotifyOptions.listeners = true;\n    }\n\n    this.notify({ ...defaultNotifyOptions,\n      ...notifyOptions\n    });\n  }\n\n  updateQuery() {\n    const query = this.client.getQueryCache().build(this.client, this.options);\n\n    if (query === this.currentQuery) {\n      return;\n    }\n\n    const prevQuery = this.currentQuery;\n    this.currentQuery = query;\n    this.currentQueryInitialState = query.state;\n    this.previousQueryResult = this.currentResult;\n\n    if (this.hasListeners()) {\n      prevQuery == null ? void 0 : prevQuery.removeObserver(this);\n      query.addObserver(this);\n    }\n  }\n\n  onQueryUpdate(action) {\n    const notifyOptions = {};\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = !action.manual;\n    } else if (action.type === 'error' && !isCancelledError(action.error)) {\n      notifyOptions.onError = true;\n    }\n\n    this.updateResult(notifyOptions);\n\n    if (this.hasListeners()) {\n      this.updateTimers();\n    }\n  }\n\n  notify(notifyOptions) {\n    notifyManager.batch(() => {\n      // First trigger the configuration callbacks\n      if (notifyOptions.onSuccess) {\n        var _this$options$onSucce, _this$options, _this$options$onSettl, _this$options2;\n\n        (_this$options$onSucce = (_this$options = this.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options, this.currentResult.data);\n        (_this$options$onSettl = (_this$options2 = this.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options2, this.currentResult.data, null);\n      } else if (notifyOptions.onError) {\n        var _this$options$onError, _this$options3, _this$options$onSettl2, _this$options4;\n\n        (_this$options$onError = (_this$options3 = this.options).onError) == null ? void 0 : _this$options$onError.call(_this$options3, this.currentResult.error);\n        (_this$options$onSettl2 = (_this$options4 = this.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options4, undefined, this.currentResult.error);\n      } // Then trigger the listeners\n\n\n      if (notifyOptions.listeners) {\n        this.listeners.forEach(listener => {\n          listener(this.currentResult);\n        });\n      } // Then the cache listeners\n\n\n      if (notifyOptions.cache) {\n        this.client.getQueryCache().notify({\n          query: this.currentQuery,\n          type: 'observerResultsUpdated'\n        });\n      }\n    });\n  }\n\n}\n\nfunction shouldLoadOnMount(query, options) {\n  return options.enabled !== false && !query.state.dataUpdatedAt && !(query.state.status === 'error' && options.retryOnMount === false);\n}\n\nfunction shouldFetchOnMount(query, options) {\n  return shouldLoadOnMount(query, options) || query.state.dataUpdatedAt > 0 && shouldFetchOn(query, options, options.refetchOnMount);\n}\n\nfunction shouldFetchOn(query, options, field) {\n  if (options.enabled !== false) {\n    const value = typeof field === 'function' ? field(query) : field;\n    return value === 'always' || value !== false && isStale(query, options);\n  }\n\n  return false;\n}\n\nfunction shouldFetchOptionally(query, prevQuery, options, prevOptions) {\n  return options.enabled !== false && (query !== prevQuery || prevOptions.enabled === false) && (!options.suspense || query.state.status !== 'error') && isStale(query, options);\n}\n\nfunction isStale(query, options) {\n  return query.isStaleByTime(options.staleTime);\n}\n\nexport { QueryObserver };\n//# sourceMappingURL=queryObserver.esm.js.map\n","import { useSyncExternalStore as useSyncExternalStore$1 } from 'use-sync-external-store/shim/index.js';\n\n// Temporary workaround due to an issue with react-native uSES - https://github.com/TanStack/query/pull/3601\nconst useSyncExternalStore = useSyncExternalStore$1;\n\nexport { useSyncExternalStore };\n//# sourceMappingURL=useSyncExternalStore.esm.js.map\n","import * as React from 'react';\n\nconst defaultContext = /*#__PURE__*/React.createContext(undefined);\nconst QueryClientSharingContext = /*#__PURE__*/React.createContext(false); // If we are given a context, we will use it.\n// Otherwise, if contextSharing is on, we share the first and at least one\n// instance of the context across the window\n// to ensure that if React Query is used across\n// different bundles or microfrontends they will\n// all use the same **instance** of context, regardless\n// of module scoping.\n\nfunction getQueryClientContext(context, contextSharing) {\n  if (context) {\n    return context;\n  }\n\n  if (contextSharing && typeof window !== 'undefined') {\n    if (!window.ReactQueryClientContext) {\n      window.ReactQueryClientContext = defaultContext;\n    }\n\n    return window.ReactQueryClientContext;\n  }\n\n  return defaultContext;\n}\n\nconst useQueryClient = ({\n  context\n} = {}) => {\n  const queryClient = React.useContext(getQueryClientContext(context, React.useContext(QueryClientSharingContext)));\n\n  if (!queryClient) {\n    throw new Error('No QueryClient set, use QueryClientProvider to set one');\n  }\n\n  return queryClient;\n};\nconst QueryClientProvider = ({\n  client,\n  children,\n  context,\n  contextSharing = false\n}) => {\n  React.useEffect(() => {\n    client.mount();\n    return () => {\n      client.unmount();\n    };\n  }, [client]);\n\n  if (process.env.NODE_ENV !== 'production' && contextSharing) {\n    client.getLogger().error(\"The contextSharing option has been deprecated and will be removed in the next major version\");\n  }\n\n  const Context = getQueryClientContext(context, contextSharing);\n  return /*#__PURE__*/React.createElement(QueryClientSharingContext.Provider, {\n    value: !context && contextSharing\n  }, /*#__PURE__*/React.createElement(Context.Provider, {\n    value: client\n  }, children));\n};\n\nexport { QueryClientProvider, defaultContext, useQueryClient };\n//# sourceMappingURL=QueryClientProvider.esm.js.map\n","import * as React from 'react';\n\nconst IsRestoringContext = /*#__PURE__*/React.createContext(false);\nconst useIsRestoring = () => React.useContext(IsRestoringContext);\nconst IsRestoringProvider = IsRestoringContext.Provider;\n\nexport { IsRestoringProvider, useIsRestoring };\n//# sourceMappingURL=isRestoring.esm.js.map\n","import * as React from 'react';\n\nfunction createValue() {\n  let isReset = false;\n  return {\n    clearReset: () => {\n      isReset = false;\n    },\n    reset: () => {\n      isReset = true;\n    },\n    isReset: () => {\n      return isReset;\n    }\n  };\n}\n\nconst QueryErrorResetBoundaryContext = /*#__PURE__*/React.createContext(createValue()); // HOOK\n\nconst useQueryErrorResetBoundary = () => React.useContext(QueryErrorResetBoundaryContext); // COMPONENT\n\nconst QueryErrorResetBoundary = ({\n  children\n}) => {\n  const [value] = React.useState(() => createValue());\n  return /*#__PURE__*/React.createElement(QueryErrorResetBoundaryContext.Provider, {\n    value: value\n  }, typeof children === 'function' ? children(value) : children);\n};\n\nexport { QueryErrorResetBoundary, useQueryErrorResetBoundary };\n//# sourceMappingURL=QueryErrorResetBoundary.esm.js.map\n","function shouldThrowError(_useErrorBoundary, params) {\n  // Allow useErrorBoundary function to override throwing behavior on a per-error basis\n  if (typeof _useErrorBoundary === 'function') {\n    return _useErrorBoundary(...params);\n  }\n\n  return !!_useErrorBoundary;\n}\n\nexport { shouldThrowError };\n//# sourceMappingURL=utils.esm.js.map\n","import * as React from 'react';\nimport { shouldThrowError } from './utils.esm.js';\n\nconst ensurePreventErrorBoundaryRetry = (options, errorResetBoundary) => {\n  if (options.suspense || options.useErrorBoundary) {\n    // Prevent retrying failed query if the error boundary has not been reset yet\n    if (!errorResetBoundary.isReset()) {\n      options.retryOnMount = false;\n    }\n  }\n};\nconst useClearResetErrorBoundary = errorResetBoundary => {\n  React.useEffect(() => {\n    errorResetBoundary.clearReset();\n  }, [errorResetBoundary]);\n};\nconst getHasError = ({\n  result,\n  errorResetBoundary,\n  useErrorBoundary,\n  query\n}) => {\n  return result.isError && !errorResetBoundary.isReset() && !result.isFetching && shouldThrowError(useErrorBoundary, [result.error, query]);\n};\n\nexport { ensurePreventErrorBoundaryRetry, getHasError, useClearResetErrorBoundary };\n//# sourceMappingURL=errorBoundaryUtils.esm.js.map\n","const ensureStaleTime = defaultedOptions => {\n  if (defaultedOptions.suspense) {\n    // Always set stale time when using suspense to prevent\n    // fetching again when directly mounting after suspending\n    if (typeof defaultedOptions.staleTime !== 'number') {\n      defaultedOptions.staleTime = 1000;\n    }\n  }\n};\nconst willFetch = (result, isRestoring) => result.isLoading && result.isFetching && !isRestoring;\nconst shouldSuspend = (defaultedOptions, result, isRestoring) => (defaultedOptions == null ? void 0 : defaultedOptions.suspense) && willFetch(result, isRestoring);\nconst fetchOptimistic = (defaultedOptions, observer, errorResetBoundary) => observer.fetchOptimistic(defaultedOptions).then(({\n  data\n}) => {\n  defaultedOptions.onSuccess == null ? void 0 : defaultedOptions.onSuccess(data);\n  defaultedOptions.onSettled == null ? void 0 : defaultedOptions.onSettled(data, null);\n}).catch(error => {\n  errorResetBoundary.clearReset();\n  defaultedOptions.onError == null ? void 0 : defaultedOptions.onError(error);\n  defaultedOptions.onSettled == null ? void 0 : defaultedOptions.onSettled(undefined, error);\n});\n\nexport { ensureStaleTime, fetchOptimistic, shouldSuspend, willFetch };\n//# sourceMappingURL=suspense.esm.js.map\n","import * as React from 'react';\nimport { useSyncExternalStore } from './useSyncExternalStore.esm.js';\nimport { notifyManager } from '@tanstack/query-core';\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary.esm.js';\nimport { useQueryClient } from './QueryClientProvider.esm.js';\nimport { useIsRestoring } from './isRestoring.esm.js';\nimport { ensurePreventErrorBoundaryRetry, useClearResetErrorBoundary, getHasError } from './errorBoundaryUtils.esm.js';\nimport { ensureStaleTime, shouldSuspend, fetchOptimistic } from './suspense.esm.js';\n\nfunction useBaseQuery(options, Observer) {\n  const queryClient = useQueryClient({\n    context: options.context\n  });\n  const isRestoring = useIsRestoring();\n  const errorResetBoundary = useQueryErrorResetBoundary();\n  const defaultedOptions = queryClient.defaultQueryOptions(options); // Make sure results are optimistically set in fetching state before subscribing or updating options\n\n  defaultedOptions._optimisticResults = isRestoring ? 'isRestoring' : 'optimistic'; // Include callbacks in batch renders\n\n  if (defaultedOptions.onError) {\n    defaultedOptions.onError = notifyManager.batchCalls(defaultedOptions.onError);\n  }\n\n  if (defaultedOptions.onSuccess) {\n    defaultedOptions.onSuccess = notifyManager.batchCalls(defaultedOptions.onSuccess);\n  }\n\n  if (defaultedOptions.onSettled) {\n    defaultedOptions.onSettled = notifyManager.batchCalls(defaultedOptions.onSettled);\n  }\n\n  ensureStaleTime(defaultedOptions);\n  ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary);\n  useClearResetErrorBoundary(errorResetBoundary);\n  const [observer] = React.useState(() => new Observer(queryClient, defaultedOptions));\n  const result = observer.getOptimisticResult(defaultedOptions);\n  useSyncExternalStore(React.useCallback(onStoreChange => isRestoring ? () => undefined : observer.subscribe(notifyManager.batchCalls(onStoreChange)), [observer, isRestoring]), () => observer.getCurrentResult(), () => observer.getCurrentResult());\n  React.useEffect(() => {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    observer.setOptions(defaultedOptions, {\n      listeners: false\n    });\n  }, [defaultedOptions, observer]); // Handle suspense\n\n  if (shouldSuspend(defaultedOptions, result, isRestoring)) {\n    throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary);\n  } // Handle error boundary\n\n\n  if (getHasError({\n    result,\n    errorResetBoundary,\n    useErrorBoundary: defaultedOptions.useErrorBoundary,\n    query: observer.getCurrentQuery()\n  })) {\n    throw result.error;\n  } // Handle result property usage tracking\n\n\n  return !defaultedOptions.notifyOnChangeProps ? observer.trackResult(result) : result;\n}\n\nexport { useBaseQuery };\n//# sourceMappingURL=useBaseQuery.esm.js.map\n","import { parseQueryArgs, QueryObserver } from '@tanstack/query-core';\nimport { useBaseQuery } from './useBaseQuery.esm.js';\n\nfunction useQuery(arg1, arg2, arg3) {\n  const parsedOptions = parseQueryArgs(arg1, arg2, arg3);\n  return useBaseQuery(parsedOptions, QueryObserver);\n}\n\nexport { useQuery };\n//# sourceMappingURL=useQuery.esm.js.map\n"],"names":["DEV_DOT_TO_USERNAME","ARTICLES_API","parseResponse","response","devdottoArticlesMeta","articles","page","Subscribable","listener","x","isServer","noop","isValidTimeout","value","timeUntilStale","updatedAt","staleTime","parseQueryArgs","arg1","arg2","arg3","isQueryKey","replaceEqualDeep","a","b","array","isPlainArray","isPlainObject","aSize","bItems","bSize","copy","equalItems","i","key","shallowEqualObjects","o","hasObjectPrototype","ctor","prot","sleep","timeout","resolve","scheduleMicrotask","callback","replaceData","prevData","data","options","FocusManager","onFocus","_this$cleanup","setup","_this$cleanup2","focused","focusManager","OnlineManager","onOnline","online","onlineManager","canFetch","networkMode","CancelledError","isCancelledError","createNotifyManager","queue","transactions","notifyFn","batchNotifyFn","batch","result","flush","schedule","batchCalls","args","originalQueue","fn","notifyManager","QueryObserver","client","shouldFetchOnMount","shouldFetchOn","notifyOptions","prevOptions","prevQuery","mounted","shouldFetchOptionally","nextRefetchInterval","query","trackedResult","refetchPage","defaultedOptions","fetchOptions","_fetchOptions$cancelR","promise","_this$options$refetch","nextInterval","prevResult","prevResultState","prevResultOptions","queryChange","queryInitialState","prevQueryResult","state","dataUpdatedAt","error","errorUpdatedAt","fetchStatus","status","isPreviousData","isPlaceholderData","fetchOnMount","fetchOptionally","selectError","placeholderData","isFetching","isLoading","isError","isStale","nextResult","defaultNotifyOptions","shouldNotifyListeners","notifyOnChangeProps","includedProps","typedKey","action","_this$options$onSucce","_this$options","_this$options$onSettl","_this$options2","_this$options$onError","_this$options3","_this$options$onSettl2","_this$options4","shouldLoadOnMount","field","useSyncExternalStore","useSyncExternalStore$1","defaultContext","React.createContext","QueryClientSharingContext","getQueryClientContext","context","contextSharing","useQueryClient","queryClient","React.useContext","IsRestoringContext","useIsRestoring","createValue","isReset","QueryErrorResetBoundaryContext","useQueryErrorResetBoundary","shouldThrowError","_useErrorBoundary","params","ensurePreventErrorBoundaryRetry","errorResetBoundary","useClearResetErrorBoundary","React.useEffect","getHasError","useErrorBoundary","ensureStaleTime","willFetch","isRestoring","shouldSuspend","fetchOptimistic","observer","useBaseQuery","Observer","React.useState","React.useCallback","onStoreChange","useQuery","parsedOptions"],"mappings":"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"}